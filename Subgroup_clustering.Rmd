---
title: "Subgroup clustering"
author: "Florian Bieberich"
date: "10/13/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, error = FALSE)
require("knitr")
opts_knit$set(root.dir = "/Users/florian/Desktop/Cambridge_Bioinformatics/Pipeline_project/R_workspace/")
```

```{r a, echo=FALSE, include=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("GenomicAlignments")
biocLite("Rsamtools")
biocLite("GenomicRanges")
library(GenomicAlignments)
library(Rsamtools)
library(GenomicRanges)
```

Preparation of SAM table that was previously transformed to .txt (in bash) and supplementary columns

```{r z, eval=FALSE, engine='bash'}
awk '{print $1,$2,$3,$4,$5,$6}' alignment.sam > align_filtered.txt #first 6 columns in new .txt file
```

The first six columns are named in the typical SAM format. 
The 7th column contains the read length (without softclipped region) and the 8th the query length (with softclipped region).

```{r b}
alignments_cell4 = read.table("align_filtered.txt", skip=1)
colnames(alignments_cell4) <- c("QNAME", "FLAG", "RNAME", "POS", "MAPQ", "CIGAR")
Read_len <- cigarWidthAlongReferenceSpace(alignments_cell4[,6]) #extract length from CIGAR string without softclips
Query_len <- cigarWidthAlongQuerySpace(alignments_cell4[,6]) #with softclipped regions
align_cell4_len <- cbind(alignments_cell4, Read_len, Query_len) #append to dataframe
align_cell4_len$POS <- as.numeric(as.character(align_cell4_len$POS))
align_cell4_len <- align_cell4_len[complete.cases(align_cell4_len[ ,4]),] #removes NA from the 4th column
```

Implementation of GRanges object to work with in further analysis.

```{r c}
gr4 = with(align_cell4_len, GRanges(RNAME, IRanges(start = POS, width = Read_len, names = QNAME), strand = ifelse(FLAG=="0", "+", "-")))
```

Detection of paired overlaps with more than 99 bases. 
Threshold can be adjusted - depending on read quality.

```{r d}
overlap <- findOverlaps(gr4, minoverlap = 100)
```

Preparation for clustering of reads by splitting the overlapped reads for each read into list of vectors. 
Particularly, each vector contains the respective overlapped reads. 
The cluster id list is used in further analysis to assign overlapping reads to the same cluster.

```{r e}
overlap_list <- split(subjectHits(overlap),queryHits(overlap)) #List of vectors, each vector shows reads that overlap with list$vector (read of the vector) 
cluster_id <- rep(0, queryLength(overlap)) #empty cluster_id for grouping of overlapping reads
```

Loop for iterating over overlapped reads and changing cluster_id to current element and indexed cluster_id' 's that are already unequal zero to current element.
This takes care that all previously overlapping reads are grouped together in a new cluster if a recent read also overlaps with more than one cluster (id).

```{r f}
for (element in names(overlap_list)) {
  reads <- overlap_list[[element]]
  change.id <- cluster_id[reads]
  change.id <- change.id[change.id!=0]
  cluster_id[cluster_id%in%change.id] <- as.integer(element)
  cluster_id[reads] <- as.integer(element)
} 
```

Loop gives out cluster_id whose index corresponds to index of read in initial SAM file. 
Cluster_ids allow to group reads with their overlapping (more than 99 bases) reads.




